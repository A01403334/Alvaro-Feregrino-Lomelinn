# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IhctUwsIVzRQxEDNBaJJPVp3Y2VSFMKP
"""

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf

# Define the stocks and date range
tickers = ['MSFT', 'AMZN', 'CAT']
start_date = '2019-01-29'
end_date = '2025-04-08'

# Fetch historical stock data (default auto_adjust=True, so use 'Close' for adjusted prices)
data = yf.download(tickers, start=start_date, end=end_date, progress=False)['Close']

# Calculate daily returns
returns = data.pct_change().dropna()

# Parameters for random walk simulation
n_days = len(data)
np.random.seed(42)  # For reproducibility

# Function to simulate random walk
def simulate_random_walk(initial_price, returns_mean, returns_std, n_days):
    daily_returns = np.random.normal(loc=returns_mean, scale=returns_std, size=n_days)
    price_path = initial_price * np.cumprod(1 + daily_returns)
    return price_path

# Simulate random walks for each stock
simulated_paths = {}
for ticker in tickers:
    initial_price = data[ticker].iloc[0]
    returns_mean = returns[ticker].mean()
    returns_std = returns[ticker].std()
    simulated_paths[ticker] = simulate_random_walk(initial_price, returns_mean, returns_std, n_days)

# Convert simulated paths to DataFrame
simulated_df = pd.DataFrame(simulated_paths, index=data.index)

# Perform Augmented Dickey-Fuller test for unit root
def adf_test(series, ticker):
    result = adfuller(series.dropna())
    print(f'\nADF Test for {ticker}:')
    print(f'ADF Statistic: {result[0]:.4f}')
    print(f'p-value: {result[1]:.4f}')
    print('Critical Values:')
    for key, value in result[4].items():
        print(f'   {key}: {value:.4f}')
    if result[1] < 0.05:
        print(f"Conclusion: Reject the null hypothesis - {ticker} is likely stationary.")
    else:
        print(f"Conclusion: Fail to reject the null hypothesis - {ticker} has a unit root (random walk).")

# Run ADF test on actual prices
for ticker in tickers:
    adf_test(data[ticker], ticker)

# Plotting
plt.figure(figsize=(14, 12))

# Plot 1: Actual vs Simulated Prices
for i, ticker in enumerate(tickers, 1):
    plt.subplot(3, 3, i)
    plt.plot(data.index, data[ticker], label=f'{ticker} Actual', color='blue')
    plt.plot(simulated_df.index, simulated_df[ticker], label=f'{ticker} Simulated', color='orange', alpha=0.7)
    plt.title(f'{ticker}: Actual vs Simulated Random Walk')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.legend()
    plt.grid(True)

# Plot 2: Correlograms (ACF of Returns)
for i, ticker in enumerate(tickers, 1):
    plt.subplot(3, 3, i + 3)
    plot_acf(returns[ticker].dropna(), lags=20, ax=plt.gca())
    plt.title(f'{ticker}: ACF of Daily Returns')
    plt.xlabel('Lag')
    plt.ylabel('Autocorrelation')
    plt.grid(True)

# Plot 3: Actual Returns
for i, ticker in enumerate(tickers, 1):
    plt.subplot(3, 3, i + 6)
    plt.plot(returns.index, returns[ticker], color='green', alpha=0.7)
    plt.title(f'{ticker}: Daily Returns')
    plt.xlabel('Date')
    plt.ylabel('Daily Return')
    plt.grid(True)

plt.tight_layout()
plt.show()