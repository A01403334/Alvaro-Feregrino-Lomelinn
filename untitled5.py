# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ceu7je739x59grj_HeQVNChoCnyWSaJC
"""

pip install statsmodels --upgrade

import pandas as pd
import numpy as np
from google.colab import files
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.tsa.arima.model import ARIMA  # Correct import for ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import matplotlib.pyplot as plt
from typing import Dict, Optional, Any

class TimeSeriesAnalyzer:
    """Class to analyze financial time series data for stationarity and cointegration."""

    def __init__(self):
        self.data = {}
        self.tickers = ['AMZN', 'COST', 'AAPL']
        self.time_period = '1M 1D'
        self.column_mapping = {
            'AMZN': {'date': 'Date', 'close': 'Close'},
            'COST': {'date': 'Date.1', 'close': 'Close.1'},
            'AAPL': {'date': 'Date.2', 'close': 'Close.2'}
        }

    def upload_and_load_data(self) -> pd.DataFrame:
        """Upload a single Excel file containing 1M 1D data for AMZN, COST, AAPL."""
        print(f"Please upload the Excel file containing {self.time_period} data for AMZN, COST, AAPL")
        try:
            uploaded = files.upload()
            filenames = list(uploaded.keys())
            if len(filenames) != 1:
                raise ValueError(f"Expected 1 file, but {len(filenames)} were uploaded")
            fname = filenames[0]
            df = pd.read_excel(fname)
            print(f"\n{self.time_period} DataFrame columns:", list(df.columns))
            return df
        except Exception as e:
            raise ValueError(f"Error during file upload: {str(e)}")

    def load_data(self) -> None:
        """Load data from the uploaded file and store in self.data."""
        df = self.upload_and_load_data()
        for ticker in self.tickers:
            date_col = self.column_mapping[ticker]['date']
            close_col = self.column_mapping[ticker]['close']
            if close_col not in df.columns or date_col not in df.columns:
                raise KeyError(f"Columns '{date_col}' or '{close_col}' not found in {self.time_period} data")
            close_series = pd.to_numeric(df[close_col], errors='coerce')
            series = pd.Series(close_series.values, index=pd.to_datetime(df[date_col]), name=ticker)
            self.data[ticker] = series.dropna()

    @staticmethod
    def unit_root_tests(series: pd.Series, name: str) -> None:
        """Perform ADF and KPSS unit root tests with interpretations."""
        print(f"\nUnit Root Tests for {name}:")

        # ADF Test
        adf_result = adfuller(series)
        print("ADF Test:")
        print(f'ADF Statistic: {adf_result[0]:.4f}')
        print(f'p-value: {adf_result[1]:.4f}')
        print(f'Critical Values: {adf_result[4]}')
        print("\nInterpretation of ADF Test:")
        if adf_result[1] < 0.05:
            print(f"The p-value ({adf_result[1]:.4f}) is less than 0.05, so we reject the null hypothesis of a unit root.")
            print("This suggests the series is likely stationary (or trend-stationary).")
        else:
            print(f"The p-value ({adf_result[1]:.4f}) is greater than 0.05, so we fail to reject the null hypothesis.")
            print("This indicates the series may have a unit root and is likely non-stationary.")

        # KPSS Test
        kpss_result = kpss(series, regression='c', nlags="auto")
        print("\nKPSS Test:")
        print(f'KPSS Statistic: {kpss_result[0]:.4f}')
        print(f'p-value: {kpss_result[1]:.4f}')
        print(f'Critical Values: {kpss_result[3]}')
        print("\nInterpretation of KPSS Test:")
        if kpss_result[1] < 0.05:
            print(f"The p-value ({kpss_result[1]:.4f}) is less than 0.05, so we reject the null hypothesis of stationarity.")
            print("This suggests the series is likely non-stationary.")
        else:
            print(f"The p-value ({kpss_result[1]:.4f}) is greater than 0.05, so we fail to reject the null hypothesis.")
            print("This indicates the series may be stationary.")
        print("\nCombined Interpretation:")
        if adf_result[1] < 0.05 and kpss_result[1] >= 0.05:
            print("Both tests suggest the series is stationary, which is a good sign for time series modeling.")
        elif adf_result[1] >= 0.05 and kpss_result[1] < 0.05:
            print("Both tests suggest the series is non-stationary, indicating differencing may be needed.")
        else:
            print("The tests give conflicting results. Further analysis (e.g., differencing or trend analysis) may be required.")

    @staticmethod
    def find_best_arma(series: pd.Series, name: str, max_p: int = 3, max_q: int = 3) -> Any:
        """Find and fit the best ARMA model based on AIC with interpretation."""
        best_aic = float('inf')
        best_order = None

        for p in range(max_p + 1):
            for q in range(max_q + 1):
                try:
                    model = ARIMA(series, order=(p, 0, q))
                    results = model.fit()
                    if results.aic < best_aic:
                        best_aic = results.aic
                        best_order = (p, 0, q)
                except Exception:
                    continue

        print(f"\nBest ARMA model for {name}:")
        print(f"Order: {best_order}")
        print(f"AIC: {best_aic:.2f}")
        print("\nInterpretation of ARMA Model:")
        print(f"The best ARMA model has order {best_order}, with an AIC of {best_aic:.2f}.")
        print("Lower AIC values indicate a better model fit, balancing goodness-of-fit and model complexity.")
        print(f"This ARMA({best_order[0]},{best_order[2]}) model captures the autoregressive (AR) and moving average (MA) components of the differenced series.")
        print("This model can be used for forecasting, but ensure the residuals are white noise (i.e., no remaining patterns).")

        return ARIMA(series, order=best_order).fit()

    @staticmethod
    def cointegration_test(df: pd.DataFrame, time_period: str) -> None:
        """Perform Johansen cointegration test with interpretation."""
        result = coint_johansen(df, det_order=0, k_ar_diff=1)
        print(f"\nJohansen Cointegration Test ({time_period}):")
        print(f"Trace statistic: {result.lr1}")
        print(f"Critical values (90%, 95%, 99%): {result.cvt}")

        print("\nInterpretation of Johansen Cointegration Test:")
        cointegration_found = False
        for i in range(len(result.lr1)):
            if result.lr1[i] > result.cvt[i, 1]:  # 95% critical value
                print(f"r = {i}: The trace statistic ({result.lr1[i]:.2f}) exceeds the 95% critical value ({result.cvt[i, 1]:.2f}).")
                print("Cointegration exists at 95% confidence level.")
                cointegration_found = True
            else:
                print(f"r = {i}: The trace statistic ({result.lr1[i]:.2f}) does not exceed the 95% critical value ({result.cvt[i, 1]:.2f}).")
                print("No cointegration at 95% confidence level.")
        if cointegration_found:
            print("Summary: There is evidence of cointegration among AMZN, COST, and AAPL.")
            print("This suggests a long-term equilibrium relationship exists, meaning the stocks may move together over time.")
            print("This is useful for strategies like pairs trading, where deviations from the equilibrium can be exploited.")
        else:
            print("Summary: No evidence of cointegration among AMZN, COST, and AAPL.")
            print("This suggests the stocks do not share a long-term equilibrium relationship over this period.")
            print("They may move independently, making strategies like pairs trading less effective.")

    def plot_series(self, series_dict: Dict[str, pd.Series], title: str, diff: bool = False) -> None:
        """Plot original or differenced time series with interpretation."""
        plt.figure(figsize=(12, 6))
        for name, series in series_dict.items():
            plt.plot(series.index, series, label=name)
        plt.title(title)
        plt.xlabel('Date')
        plt.ylabel('Closing Price' if not diff else 'Differenced Price')
        plt.legend()
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()

        print(f"\nInterpretation of {title}:")
        if not diff:
            print("This plot shows the closing prices of AMZN, COST, and AAPL over the specified period.")
            print("Trends, volatility, and potential correlations can be observed:")
            print("- Upward or downward trends indicate overall price movements.")
            print("- High volatility (large fluctuations) suggests price instability.")
            print("- Similar movements among the stocks may indicate potential correlation or cointegration.")
        else:
            print("This plot shows the differenced series (first differences) of the closing prices.")
            print("Differencing removes trends, making the series more stationary:")
            print("- If the differenced series fluctuates around zero with no clear trend, it supports stationarity.")
            print("- Large spikes indicate significant price changes on specific dates.")
            print("- This is the series used for ARMA modeling, as it should be stationary.")

    def analyze(self) -> None:
        """Main analysis pipeline for all tickers."""
        self.load_data()
        series_dict = {}
        for ticker in self.tickers:
            series_dict[ticker] = self.data[ticker]

        common_index = series_dict[self.tickers[0]].index
        for ticker in self.tickers[1:]:
            common_index = common_index.intersection(series_dict[ticker].index)
        for ticker in self.tickers:
            series_dict[ticker] = series_dict[ticker].loc[common_index]

        for ticker, series in series_dict.items():
            self.unit_root_tests(series, f"{ticker} ({self.time_period})")

        diff_series = {ticker: series.diff().dropna() for ticker, series in series_dict.items()}
        arma_models = {ticker: self.find_best_arma(diff_series[ticker], f"{ticker} ({self.time_period})") for ticker in self.tickers}
        coint_df = pd.DataFrame(series_dict).dropna()
        self.cointegration_test(coint_df, self.time_period)
        self.plot_series(series_dict, f'Closing Prices ({self.time_period})')
        self.plot_series(diff_series, f'Differenced Series ({self.time_period})', diff=True)

def main():
    """Main function to run the analysis."""
    try:
        analyzer = TimeSeriesAnalyzer()
        analyzer.analyze()
    except Exception as e:
        print(f"An error occurred: {str(e)}")

if __name__ == "__main__":
    main()

import pandas as pd
import numpy as np
from google.colab import files
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.tsa.arima.model import ARIMA  # Correct import for ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import matplotlib.pyplot as plt
from typing import Dict, Optional, Any

class TimeSeriesAnalyzer:
    """Class to analyze financial time series data for stationarity and cointegration."""

    def __init__(self):
        self.data = {}
        self.tickers = ['AMZN', 'COST', 'AAPL']
        self.time_period = '3M 1D'
        self.column_mapping = {
            'AMZN': {'date': 'Date', 'close': 'Close'},
            'COST': {'date': 'Date.1', 'close': 'Close.1'},
            'AAPL': {'date': 'Date.2', 'close': 'Close.2'}
        }

    def upload_and_load_data(self) -> pd.DataFrame:
        """Upload a single Excel file containing 3M 1D data for AMZN, COST, AAPL."""
        print(f"Please upload the Excel file containing {self.time_period} data for AMZN, COST, AAPL")
        try:
            uploaded = files.upload()
            filenames = list(uploaded.keys())
            if len(filenames) != 1:
                raise ValueError(f"Expected 1 file, but {len(filenames)} were uploaded")
            fname = filenames[0]
            df = pd.read_excel(fname)
            print(f"\n{self.time_period} DataFrame columns:", list(df.columns))
            return df
        except Exception as e:
            raise ValueError(f"Error during file upload: {str(e)}")

    def load_data(self) -> None:
        """Load data from the uploaded file and store in self.data."""
        df = self.upload_and_load_data()
        for ticker in self.tickers:
            date_col = self.column_mapping[ticker]['date']
            close_col = self.column_mapping[ticker]['close']
            if close_col not in df.columns or date_col not in df.columns:
                raise KeyError(f"Columns '{date_col}' or '{close_col}' not found in {self.time_period} data")
            close_series = pd.to_numeric(df[close_col], errors='coerce')
            series = pd.Series(close_series.values, index=pd.to_datetime(df[date_col]), name=ticker)
            self.data[ticker] = series.dropna()

    @staticmethod
    def unit_root_tests(series: pd.Series, name: str) -> None:
        """Perform ADF and KPSS unit root tests with interpretations."""
        print(f"\nUnit Root Tests for {name}:")

        # ADF Test
        adf_result = adfuller(series)
        print("ADF Test:")
        print(f'ADF Statistic: {adf_result[0]:.4f}')
        print(f'p-value: {adf_result[1]:.4f}')
        print(f'Critical Values: {adf_result[4]}')
        print("\nInterpretation of ADF Test:")
        if adf_result[1] < 0.05:
            print(f"The p-value ({adf_result[1]:.4f}) is less than 0.05, so we reject the null hypothesis of a unit root.")
            print("This suggests the series is likely stationary (or trend-stationary).")
        else:
            print(f"The p-value ({adf_result[1]:.4f}) is greater than 0.05, so we fail to reject the null hypothesis.")
            print("This indicates the series may have a unit root and is likely non-stationary.")

        # KPSS Test
        kpss_result = kpss(series, regression='c', nlags="auto")
        print("\nKPSS Test:")
        print(f'KPSS Statistic: {kpss_result[0]:.4f}')
        print(f'p-value: {kpss_result[1]:.4f}')
        print(f'Critical Values: {kpss_result[3]}')
        print("\nInterpretation of KPSS Test:")
        if kpss_result[1] < 0.05:
            print(f"The p-value ({kpss_result[1]:.4f}) is less than 0.05, so we reject the null hypothesis of stationarity.")
            print("This suggests the series is likely non-stationary.")
        else:
            print(f"The p-value ({kpss_result[1]:.4f}) is greater than 0.05, so we fail to reject the null hypothesis.")
            print("This indicates the series may be stationary.")
        print("\nCombined Interpretation:")
        if adf_result[1] < 0.05 and kpss_result[1] >= 0.05:
            print("Both tests suggest the series is stationary, which is a good sign for time series modeling.")
        elif adf_result[1] >= 0.05 and kpss_result[1] < 0.05:
            print("Both tests suggest the series is non-stationary, indicating differencing may be needed.")
        else:
            print("The tests give conflicting results. Further analysis (e.g., differencing or trend analysis) may be required.")

    @staticmethod
    def find_best_arma(series: pd.Series, name: str, max_p: int = 3, max_q: int = 3) -> Any:
        """Find and fit the best ARMA model based on AIC with interpretation."""
        best_aic = float('inf')
        best_order = None

        for p in range(max_p + 1):
            for q in range(max_q + 1):
                try:
                    model = ARIMA(series, order=(p, 0, q))
                    results = model.fit()
                    if results.aic < best_aic:
                        best_aic = results.aic
                        best_order = (p, 0, q)
                except Exception:
                    continue

        print(f"\nBest ARMA model for {name}:")
        print(f"Order: {best_order}")
        print(f"AIC: {best_aic:.2f}")
        print("\nInterpretation of ARMA Model:")
        print(f"The best ARMA model has order {best_order}, with an AIC of {best_aic:.2f}.")
        print("Lower AIC values indicate a better model fit, balancing goodness-of-fit and model complexity.")
        print(f"This ARMA({best_order[0]},{best_order[2]}) model captures the autoregressive (AR) and moving average (MA) components of the differenced series.")
        print("This model can be used for forecasting, but ensure the residuals are white noise (i.e., no remaining patterns).")

        return ARIMA(series, order=best_order).fit()

    @staticmethod
    def cointegration_test(df: pd.DataFrame, time_period: str) -> None:
        """Perform Johansen cointegration test with interpretation."""
        result = coint_johansen(df, det_order=0, k_ar_diff=1)
        print(f"\nJohansen Cointegration Test ({time_period}):")
        print(f"Trace statistic: {result.lr1}")
        print(f"Critical values (90%, 95%, 99%): {result.cvt}")

        print("\nInterpretation of Johansen Cointegration Test:")
        cointegration_found = False
        for i in range(len(result.lr1)):
            if result.lr1[i] > result.cvt[i, 1]:  # 95% critical value
                print(f"r = {i}: The trace statistic ({result.lr1[i]:.2f}) exceeds the 95% critical value ({result.cvt[i, 1]:.2f}).")
                print("Cointegration exists at 95% confidence level.")
                cointegration_found = True
            else:
                print(f"r = {i}: The trace statistic ({result.lr1[i]:.2f}) does not exceed the 95% critical value ({result.cvt[i, 1]:.2f}).")
                print("No cointegration at 95% confidence level.")
        if cointegration_found:
            print("Summary: There is evidence of cointegration among AMZN, COST, and AAPL.")
            print("This suggests a long-term equilibrium relationship exists, meaning the stocks may move together over time.")
            print("This is useful for strategies like pairs trading, where deviations from the equilibrium can be exploited.")
        else:
            print("Summary: No evidence of cointegration among AMZN, COST, and AAPL.")
            print("This suggests the stocks do not share a long-term equilibrium relationship over this period.")
            print("They may move independently, making strategies like pairs trading less effective.")

    def plot_series(self, series_dict: Dict[str, pd.Series], title: str, diff: bool = False) -> None:
        """Plot original or differenced time series with interpretation."""
        plt.figure(figsize=(12, 6))
        for name, series in series_dict.items():
            plt.plot(series.index, series, label=name)
        plt.title(title)
        plt.xlabel('Date')
        plt.ylabel('Closing Price' if not diff else 'Differenced Price')
        plt.legend()
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()

        print(f"\nInterpretation of {title}:")
        if not diff:
            print("This plot shows the closing prices of AMZN, COST, and AAPL over the specified period.")
            print("Trends, volatility, and potential correlations can be observed:")
            print("- Upward or downward trends indicate overall price movements.")
            print("- High volatility (large fluctuations) suggests price instability.")
            print("- Similar movements among the stocks may indicate potential correlation or cointegration.")
        else:
            print("This plot shows the differenced series (first differences) of the closing prices.")
            print("Differencing removes trends, making the series more stationary:")
            print("- If the differenced series fluctuates around zero with no clear trend, it supports stationarity.")
            print("- Large spikes indicate significant price changes on specific dates.")
            print("- This is the series used for ARMA modeling, as it should be stationary.")

    def analyze(self) -> None:
        """Main analysis pipeline for all tickers."""
        self.load_data()
        series_dict = {}
        for ticker in self.tickers:
            series_dict[ticker] = self.data[ticker]

        common_index = series_dict[self.tickers[0]].index
        for ticker in self.tickers[1:]:
            common_index = common_index.intersection(series_dict[ticker].index)
        for ticker in self.tickers:
            series_dict[ticker] = series_dict[ticker].loc[common_index]

        for ticker, series in series_dict.items():
            self.unit_root_tests(series, f"{ticker} ({self.time_period})")

        diff_series = {ticker: series.diff().dropna() for ticker, series in series_dict.items()}
        arma_models = {ticker: self.find_best_arma(diff_series[ticker], f"{ticker} ({self.time_period})") for ticker in self.tickers}
        coint_df = pd.DataFrame(series_dict).dropna()
        self.cointegration_test(coint_df, self.time_period)
        self.plot_series(series_dict, f'Closing Prices ({self.time_period})')
        self.plot_series(diff_series, f'Differenced Series ({self.time_period})', diff=True)

def main():
    """Main function to run the analysis."""
    try:
        analyzer = TimeSeriesAnalyzer()
        analyzer.analyze()
    except Exception as e:
        print(f"An error occurred: {str(e)}")

if __name__ == "__main__":
    main()